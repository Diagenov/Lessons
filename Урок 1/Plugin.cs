/*

I. Как начать подготовить решение к написанию плагина.

1) Открыть студию -> Файлы -> Создать -> Проект 
2) Откроется окно создания проекта. В нем настравиваем:
    a) Выбираем пункт 'Библиотека классов (.NET Framework)'
    б) Задаем название проекта, его расположение 
    в) Выбираем платформу .NET Framework 4.5 (Это важно)
3) Когда создастся проект, нужно добавить ссылки (API игры, игрового сервера и tShock'a)
    а) Скачайте файлы OTAPI.dll, TShockAPI.dll и TerrariaServer.exe (пришлю в Дискорде)
    б) Удобнее всего поместить их в отдельную папку, а папку перенести в файлы проекта (подпункт б в предыдущем пункте)
    в) Проект -> Добавить ссылку -> Обзор -> Выбираете скачанные файлы (удобнее сначала выполнить подпункт (б)) -> Ок
4) Решение готово. Перейдем к написанию кода!


II. Введение в синтаксис. Продолжаем подготавливать решение к написанию плагина.

1) В самом верху находятся подключаемые модули (пространства имен). Подключая модуль, вы можете пользоваться его инструментами, которые определены в нем.  
*/
using System; //Например, это пространство имен содержит класс Console, который можно использовать для вывода текста в консоль.
using TerrariaApi.Server; // Этот модуль понадобится нам для написания плагина. Он находится в TerrariaServer.exe.
using TShockAPI; // Этот модуль, по сути, сам является плагином, использующий предыдущий модуль.  
                 // Но на его основе написаны многие, если не все, плагины, так как он предоставляет кучу удобных иснтрументов, облегчяя нам работу тем самым.
using Terraria; // Этот модуль содержит API игры. Он находится в OTAPI.dll.

// То, что некоторые модули подсвечиваются бледно-серым цветом, означает, что мы нигде не использовали их инструменты.

/*
2) Здесь начало нашего пространства имен. После ключевого слова namespace идет его название.
   В фигурные скобки заключено тело нашего пространства имен. Можно провести аналогию с телом человека.
   Кожа - наши фигурные скобки, в которых находятся различные органы.
*/
namespace Lessons
{
    /*
    3) В теле пространства имен определены классы. Возвращаясь к нашей аналогии, классы можно назвать органами.
       У классов также есть тело, как у органа - его оболочка.
       Для начала нам нужно определить класс плагина. У этого есть свои правила.
    */
    [ApiVersion(2, 1)] // Перед классом плагина нужно обязательно пишем, какая у него версия. 
                       // Такие конструкции называются атрибутами, но пока нам не обязательно знать, что это и для чего оно нужно.
    public class Plugin : TerrariaPlugin // Эта запись означает, что наш класс наследует все от класса TerrariaPlugin
                                         // Аналогия очевидна: ваши родители - TerrariaPlugin, а вы - Plugin, которые унаследовали их черты
                                         // Можно пока не вникать в эту тему, которая коротко можно назвать 'Наследование'
                                         // TerrariaPlugin - класс, который находится в модуле TerrariaApi.Server
    {
        /*
        4) Это называется конструктор класса. Он вызывается, когда мы создаем объект класса.
           Например, у нас есть определение класса Plugin. Мы можем создать его объект: Plugin x = new Plugin()
           Когда объект создается, вызывается конструктор. Конструкторов может быть несколько.
           У этого конструктора есть параметр Main game. Это значит, что при создании объекта этого класса нам надо передать в его конструктор объект класса Main.
           Поэтому предыдущий пример надо периписать так: Plugin x = new Plugin(game), где game - это объект класса Main

           Аналогию можно провести с созданием ложек. У вас есть форма для заливки металла, которая выполнена в виде ложки - это наш конструктор.
           Понятие ложки, то, как мы ее себе представляем - это определение класса, а его объект - это конкретная ложка, которую можно подержать в руках.
           В форму мы можем залить не только железо, но и цинк, и серебро, и золото - это параметры, которые мы передаем в конструктор. Они могут быть разными, но для данного конструктора это обязательно должен быть металл.
           А, например, для другого конструктора - другой формы - это может быть не один металл, а его сплав. 

           То, что идет после :, тоже связано с наследованием. Не будем вникать в это. Просто запомните, что в классе плагина конструктор должен именно так выглядеть.
        */
        public Plugin(Main game) : base(game) // Main - класс из модуля Terraria
        {
            // У конструктора тоже есть тело, в котором можно записать какие-нибудь операции
            // Возвращаясь к нашей аналогии, мы можем сделать для нашей ложки какой-нибудь рисунок при его создании
        }

        /*
        5) Это метод. Сначала обычно ставят модификатор доступа: public, private и т.д. Но мы пока все будем делать с модификатором public
           
            Ключевое слово override говорит о том, что мы переопределяем метод, который определен в родительском классе TerrariaPlugin.
           Проводя аналогию с родителями, у них есть семейное дело, которое вы наследуете - наследуемый метод.
           И вы можете переопределить родительский бизнесс под ваши нужды, например.
           Но пока мы в наследование лезть не будем, поэтому просто запомните, что в классе плагина важно написать переопределение этого метода

           Ключевое слово void означает, что вы ничего не возвращаете после вызова метода.
        */
        public override void Initialize()
        {
            // У метода тоже есть тело
            // Обычно в теле метода Initialize осуществляются подписки на хуки, но об этом позже
        }

        /*
        6) VS не будет ругаться, если не переопределить этот метод. 
           Но если вы сделали подписку на хуки, то здесь нужно обязательно отписаться от них, чтобы освободить место.
           Пока просто запомните синтаксис этого метода, ибо он также составляет структуру плагина.
           bool disposing - это передаваемый в метод параметр. Можно провести аналогию с функцией f(x).
           Например, f(x) - метод, а x - передаваемый в нее параметр. В теле
        */
        protected override void Dispose(bool disposing)
        {
            // В теле метода могут происходить всякие операции. 
            // По аналогии с функцией, f(x) = x + 1 - то есть, после того, как мы передали в функцию (метод) параметр x, в ее 'теле' произошла некоторая операция (увеличели x на единицу).
            // Можно провести аналогию с автоматом с жвачкой. Автомат - это метод. Он принимает один параметр - монетку.
            // Внутри автомата - внутри его тела - проводятся какие-то операции. На выходе вы получаете жвачку (если простым языком, вместо void стояла бы 'жвачка')

            // Это называется условная конструкция. Об этом потом. Пока просто запомните, что тело метода Dispose должно так выглядеть.
            if (disposing)
            {
                // Тут осуществляется отписка от хуков
            }
            base.Dispose(disposing); // Здесь вызвается родительский метод.
                                     // По аналогии с родительским бизнесом, вы не просто переопределили его, а построили поверх него свой бизнесс.
                                     // Сначала работает ваш бизнесс, а потом - бизнесс родителей. Но, опять же, пока не вникаем в наследование.
        }
    }
}
/*
      На этом пока все. Задавайте свои вопросы в Дискорде в специальном канале.
      Спасибо за внивание!
*/
