/*
     В этом уроке постараюсь вам рассказать про типы данных, локальные переменные и поля.
     Не пугайтесь слов, это не очень сложно. Нужно просто разобраться.
*/


using System;
using TerrariaApi.Server; 
using TShockAPI; 
using Terraria; 

namespace Lessons
{
    [ApiVersion(2, 1)] 
    public class Plugin : TerrariaPlugin 
    {
        /*
            Начнем с полей. Поле - это некоторая переменная, которая хранится в экземпляре объекта класса (или которая хранится в классе, если говорить не слишком строго)
            Для справки, сейчас мы находимся в теле класса Plugin. Plugin - объект класса (или просто класс), некоторая абстрация. Мы можем создать экземляр объекта Plugin. Но об этом немного было в прошлом уроке.
            Давайте определим в Plugin какую-нибудь переменную (поле)
        */

        int pole_1; // Это некоторая переменная типа int (целое число). По умолчанию модификатор доступа этого поля стоит private.
        private int pole_2; // Мы можем сами указать модификатор доступа. private - не может быть использован извне, но только внутри Plugin.
        public int pole_3; // Тут уже другой модификатор доступа - public. Это поле можно использовать везде. Бывают еще protected или internal, но это вам вряд ли пригодится по крайней мере в ближайшем будущем. Но имейте ввиду, что такие тоже есть.

        static int static_pole_1; // А это статическое поле. То есть, оно будет одним и тем же для любого экземпляра объекта Plugin. Меняя его, мы меняем его сразу во всех экземплярах Plugin. Экземпляров много - статическое поле на всех них одно. Здесь тоже по умолчанию модификатор доступа private.
        public static int static_pole_2; // А тут public - можно использовать за приделами Plugin.

        int pole_4 = 16; // По умолчанию любое численное поле равно 0. Но можно задать другое дефолтное значение. Тут мы задали значение 16.
        static int static_pole_3 = 17; // Так можно делать с любыми полями: статическими или нет. Но в случае статического поля дефолтное значение будет задаваться не при создании экземпляра, а при компиляции (при запуске программы, грубо говоря)

        const int const_pole_1 = 1; // А это константа. Это такая же статическая переменная, но с одним отличием. Ее нельзя сразу не определить, и изменять в дальнейшем тоже нельзя. Здесь у нее тоже по умолчанию private. Можем поставить public.

        readonly int readonly_pole_1; // Это похоже на константу и на обычное поле. Оно для каждого экземляра объекта свое, то есть, не статическое. Его можно изменить в конструкторе Plugin (при создании экземпляра), но в других местах оно только для чтения.

        public Plugin(Main game) : base(game) // Напомню, это конструктор.
        {
            readonly_pole_1 = 1; // Здесь VS не будет ругаться на изменение этого поля для чтения.
            readonly_pole_1 = 2;

            //const_pole_1 = 1; // Но будет ругаться здесь. Просто уберите две // спереди, чтобы убедиться в этом.

            pole_1 = 1; // Поля можно определять в конструкторе.
            pole_1 = pole_2; // Можно одним полям присваивать значения как в других полях.

            /*
                Теперь познакомлю вас с разными типами данных и понятием локальной переменной.
                Локальная переменная отличается от поля тем, что она определяется в теле метода или конструктора и 'живет' до тех пор, пока не завершится вызов метода или конструктора.
            */

            int local_1; // Вот мы определили локальную переменную. Она будет жить до тех пор, пока мы не дойдем до конца тела конструктора (пока не завершится его вызов)
            int local_2 = 19; // По дефолту у численных локальных переменных значение тоже равно 0, но мы можем задать другое дефолтное значение.
                              // int - это целое число, которое можно представить комбинацией 4 байт (4 * 8 бит, бит - 0 или 1). Количество таких комбинаций и есть диапазон этого числа.
                              // int может принимать значения в диапазоне от -2147483647 до 2147483647

            short local_3; // Это тоже целое число, но занимает всего 2 байта. Может принимать значения от -32768 до 32768
            byte local_4; // Тоже целое, занимает всего один байт. Диапазон значений от 0 до 255
                          // Также есть целочисленный тип long, занимающий 8 байт. Но он вам вряд ли попадется когда-нибудь

            // Есть также аналоги всех представленных типов: uint, ushort, ulong - которые принимают только положительные значения. 
            // Байт они занимают столько же, но у uint, например, диапазон значений от 0 до 4294967295, а у ushort - от 0 до 65535

            float local_5 = 15.5f; // Это вещественный тип (число с плавающей запятой/точкой), то есть, может принимать не только целые значения. Сможете различить целые и вещественные числа? Если нет, просто загуглите.
                                   // float занимает 4 байта, как int. Его точность - 6-9 цифр после запятой. Приблизительный диапазон значений можно загуглить.
                                   // Если писать после числа букву f, то это будет означать, что это число выражено типом float
            double local_6 = 28.18271d; // Это тоже вещественный тип, но занимает 8 байт и, соответственно, имеет большую точность и больший диапазон значений.
                                        // Есть если писать после числа букву d, то это - double
            decimal local_7 = 27.12m; // Аналогично, но 16 байт и с буквой m

            // Это были численные типы, но есть и ссылочные. Их отличие от численных в том, например, что передавая число в метод, мы передаем не саму переменную, а его копию.
            // Передавая же в метод ссылочный тип, мы передаем его самого (по ссылке). Числа тоже можно по ссылке передавать, но об этом потом.

            string local_8 = "Это ссылочный тип, обозначающий строку. По сути, это массив из символов. Массив - ссылочный тип данных - класс - но о массивах позже.";
            string local_9; // По умолчанию любая переменная ссылочного типа принимает дефолтное значение null - аналог 0. Но в отличии от чисел, с ссылочными типами здесь бывает немало проблем, но об этом позже.

            local_1 = 19; // Если переназначая переменную, представляющее число, мы просто задаем ей другое значение
            local_9 = "То переназначая ссылочный тип или строчный, мы пересоздаем эксземпляр объекта или строки (хотя строка - это тоже эксземпляр объекта класса String - ссылочный тип же)";

            char local_10 = 'a'; // Это тип, обозначающий символ. Значение заключается в одинарные кавычки, в отличии от строки.
                                 // Хоть это похоже на строку, это, грубо говоря, 'численный тип', так как любому символу ставится в соответствие какое-то число.

            // Дальше покажу на примере одно из отличий ссылочных типов от численных типов (или их еще называют типами значений - более общее понятие)
        }

        public override void Initialize()
        {
            // Создадим команду. Сделаем это здесь. Если забыли, сначала сервер загружает плагины, потом создает экземпляры класса Plugin у каждого
            // и вызывает этот метод, в котором обычно совершается подписка на хуки. Команды обычно создают в другом месте, но сделаем это здесь

            Commands.ChatCommands.Add(new Command(Command, "test")); // Объясню каждый символ

            // Обращение к элементам пространства имен (namespace), класса (class), структуры (struct) и т.п. происходит посредством точки
            // Commands - класс в модуле (пространстве имен) TShockAPI (помните из первого урока, что это такое?)
            // Через точку обращаемся к статическому полю класса Commands, которое называется ChatComands.
            // У этого поля ссылочный тип - это список (List, который определен в модуле System.Collections.Generic). Список - как массив, но динамический, но об этом позже
            // Вызов методов также осуществляется через точку. Так мы вызываем метод Add у списка ChatCommands, который хранит все команды.
            // Метод Add добавляет в список новый элемент. Этот элемент мы передаем в метод в виде параметра new Command(Command, "test")
            // Этот параметр - ссылочный тип - класс Command. Мы сразу в параметрах метода Add создаем его экземпляр
            // Помните ведь, что когда мы создаем эксземпляр класса, мы вызываем его конструктор? Конструктор похожь на метод - мы также можем что-нибудь передать в конструктор
            // создание экземпляра класса всегда начинается со слова new, затем пишется его название, а в скобках передаются параметры, если их требует конструктор этого класса
            // Конструктор Command требует от нас два параметра: метод и пару строчек, которые обозначают название команды.
            // Первый параметр - метод, где будет происходить действие, когда игрок напишет команду
            // Вторые - названия команды. Мы ограничимся одним названием "test" (/test), но могли следом через запятую написать "t" (/t), например
            // Да, когда мы передаем параметры в метод или конструктор, мы делаем это через запятую
            // Все, мы создали команду /test. Определим действие, которое будет происходить, когда игрок пропишет ее - определим метод Command
        }

        void Command(CommandArgs e) // У любого метода любой команды должен быть такой вид. CommandArgs e - это параметр метода, является классом - ссылочным типом. 
                                    // Модификатор доступа и название команды могут быть любыми.
        {
            // CommandArgs содержит в себе аргументы команды в виде списка, игрока, который ее прописал, и другие полезные штуки.

            TSPlayer plr = e.Player; // Здесь мы через точку обратились к свойству Player, которое вернет нам игрока - экзмепляр класса TSPlayer
                                     // Возврат мы сохраним в локальной переменной plr. 
            var plr_2 = e.Player; // Мы могли написать просто var. Компилятор сам определит, какой это должен быть тип (так как свойство возвращает экземпляр TSPlayer, типом будет TSplayer)
            plr_2 = plr; // Но присвоим этой переменной значение plr (по сути, мы проделали то же, что и в предыдущей строчке, ведь теперь и plr_2, и plr ссылаются на e.Player)

            plr.TPlayer.name = "new name"; // С помощью точки обратимся к TPlayer - свойству TSplayer, которое вернет Player. По сути, это оригинальный класс игрока, а TSPlayer - надстройка от tShock со своими инструментами
                                           // name - поле у класса Player. Мы вызываем его и присваиваем ему новое значение. Как вы уже догадались, это поле - это имя игрока. Его можно было получить, обратившись к свойству Name у TSPlayer: plr.Name - но так мы бы не смоги его изменить, но почему - об этом позже

            e.Player.SendInfoMessage($"{plr.Name} сравним с {plr_2.Name} - они получатся одинаковыми, так как обе переменные ссылаются на один и тот же ссылочный тип - на e.Player"); // Тут мы вызвали метод SendInfoMessage, в который надо передать один параметр - строку. Это метод для отправки желтых сообщений игроку.
                                                                                                                                                                                       // Если поставить перед строчкой значок $, то в самой строке можно заключать в фигурных скобках значение некоторых переменных.


            int num = 10; // Если мы создадим переменную, обозначающее число.
            int num_2 = num; // Присвоим ее значение другой переменной
            num = 39; // Изменим первое число
            e.Player.SendErrorMessage($"То при сравнении {num} с {num_2} получим разные значения, так как это не ссылочные типы и когда мы присваивали для num_2 значение num, мы присваивали ей не сам num (не ссылку на него), а копировали num для num_2");
                // В этом проявляется отличие типов значений (в частности, численных типов) от ссылочных типов
                // Кстати, этот метод называется не так, как предыдущий для отправки сообщений. Этот отправит в чат красное сообщение
                // Есть еще SendSuccessMessage - отправит в чат зеленое сообщение

            // На этом все. Теперь расскажу вам, как скомпилировать (собрать) плагин и протестить его на своем сервере
            // Для начала обратите внимание на панель справа, которая называется 'Обозреватель решений'
            // Там в самом верху есть ваше 'Решение', а ниже него строчка, которая начинается с квадратика с C#.
            // Нажмите на него ПКМ и выберите 'Собрать'
            // Когда VS соберет плагин, в окне вывода он покажет путь к вашему плагину.
            // Скопируйте этот плагин оттуда в папку ServerPlugins, которая находится в папке сервера.
            // В этой папке уже должен находиться TShockAPI.dll
            // Когда сделаете это, перейдите назад в папку сервера и запустите TerrariaServer.exe.
            // Я вам пришлю папку сервера. Все, спасибо за внимание, задавайте вопросы, удачи!
        }

        /*
         * Так как мы не осуществляем подписки на хуки, этот метод нам не нужен. Его можно было просто удалить, но я закомментировал, чтобы не вводить вас в заблуждение после первого урока.
         * protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                
            }
            base.Dispose(disposing); 
        }*/
    }
}
